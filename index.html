<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FOCUS</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root { --dim: #444; --dimmer: #222; --mid: #888; }

    body {
      background: #000; color: #fff;
      font-family: 'Share Tech Mono', 'Courier New', monospace;
      min-height: 100vh;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
    }

    /* CRT scanlines */
    body::before {
      content: ''; position: fixed; inset: 0; z-index: 100; pointer-events: none;
      background: repeating-linear-gradient(0deg,
        transparent, transparent 2px,
        rgba(255,255,255,0.013) 2px, rgba(255,255,255,0.013) 4px);
    }

    /* Vignette */
    body::after {
      content: ''; position: fixed; inset: 0; z-index: 99; pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 45%, rgba(0,0,0,0.85) 100%);
    }

    /* â”€â”€ Timer display â”€â”€ */
    #timer-display {
      font-size: clamp(4.5rem, 18vw, 11rem);
      letter-spacing: 0.05em; line-height: 1;
      transition: text-shadow 0.4s; user-select: none;
    }
    #timer-display.running {
      text-shadow: 0 0 24px rgba(255,255,255,0.22), 0 0 70px rgba(255,255,255,0.07);
    }
    #timer-display.warning { animation: warn 0.45s ease-in-out infinite alternate; }
    @keyframes warn { from { opacity: 1; } to { opacity: 0.3; } }
    #timer-display.flash { animation: finish-flash 0.18s ease 3; }
    @keyframes finish-flash { 0%,100% { opacity: 1; } 50% { opacity: 0.05; } }

    /* â”€â”€ Colon â”€â”€ */
    #colon { display: inline-block; }
    #colon.blink      { animation: blink 1s    step-start infinite; }
    #colon.blink-fast { animation: blink 0.28s step-start infinite; }
    #colon.dimmed     { opacity: 0.2; animation: none; }
    @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.1; } }

    /* â”€â”€ Mode badge â”€â”€ */
    #mode-badge { letter-spacing: 0.35em; font-size: 0.68rem; transition: color 0.4s; min-height: 1.1em; }

    /* â”€â”€ Status line â”€â”€ */
    #status-line { font-size: 0.62rem; letter-spacing: 0.3em; color: var(--mid); min-height: 1.1em; text-align: center; }

    /* â”€â”€ Progress bar â”€â”€ */
    #prog-track { height: 1px; background: var(--dimmer); width: 100%; max-width: 440px; }
    #prog-fill  { height: 1px; background: #fff; width: 0%; transition: width 0.5s linear; box-shadow: 0 0 10px rgba(255,255,255,0.5); }

    /* â”€â”€ Session dots â”€â”€ */
    .dot { width: 7px; height: 7px; border-radius: 50%; background: var(--dimmer); border: 1px solid var(--dim); transition: background 0.35s, border-color 0.35s; }
    .dot.done   { background: #fff; border-color: #fff; }
    .dot.active { background: transparent; border-color: #fff; animation: dot-pulse 0.9s ease infinite alternate; }
    @keyframes dot-pulse { from { border-color: #fff; opacity: 1; } to { border-color: #444; opacity: 0.35; } }

    /* â”€â”€ Control buttons â”€â”€ */
    .ctrl-btn {
      font-family: 'Share Tech Mono', monospace;
      letter-spacing: 0.25em; font-size: 0.82rem;
      border: 1px solid var(--dim); color: #fff; background: transparent;
      padding: 0.58rem 1.5rem; cursor: pointer;
      transition: background 0.15s, border-color 0.15s, color 0.15s, transform 0.1s;
    }
    .ctrl-btn:hover:not(:disabled)  { background: #fff; color: #000; border-color: #fff; }
    .ctrl-btn:active:not(:disabled) { transform: scale(0.95); }
    .ctrl-btn:disabled { opacity: 0.18; cursor: not-allowed; }

    #reset-btn.confirming { border-color: #fff; color: #fff; animation: confirm-blink 0.55s ease infinite alternate; }
    @keyframes confirm-blink { from { opacity: 1; } to { opacity: 0.35; } }

    /* â”€â”€ Skip button â”€â”€ */
    #skip-btn {
      font-family: 'Share Tech Mono', monospace; font-size: 0.62rem; letter-spacing: 0.3em;
      color: var(--dim); background: none; border: none; cursor: pointer; transition: color 0.2s; padding: 0;
    }
    #skip-btn:hover { color: #fff; }

    /* â”€â”€ Toggle button â”€â”€ */
    .tog-btn {
      font-family: 'Share Tech Mono', monospace; font-size: 0.6rem; letter-spacing: 0.15em;
      color: var(--dim); background: none; border: 1px solid var(--dimmer); cursor: pointer;
      padding: 0.32rem 0.8rem; transition: color 0.2s, border-color 0.2s;
    }
    .tog-btn:hover { color: #888; border-color: #444; }
    .tog-btn.on    { color: #fff; border-color: var(--dim); }

    /* â”€â”€ Edit settings button â”€â”€ */
    #edit-btn {
      font-family: 'Share Tech Mono', monospace; font-size: 0.62rem; letter-spacing: 0.3em;
      color: var(--dim); background: none; border: none; cursor: pointer; transition: color 0.2s;
    }
    #edit-btn:hover:not(:disabled) { color: #fff; }
    #edit-btn:disabled { color: var(--dimmer); cursor: not-allowed; }

    /* â”€â”€ Settings panel â”€â”€ */
    #settings-panel {
      border: 1px solid var(--dimmer); padding: 1.4rem 1.8rem;
      transition: opacity 0.25s, transform 0.25s; width: 100%;
    }
    #settings-panel.hidden { opacity: 0; pointer-events: none; transform: translateY(-10px); }

    .s-label { font-size: 0.58rem; letter-spacing: 0.28em; color: var(--dim); text-transform: uppercase; }
    .s-input {
      font-family: 'Share Tech Mono', monospace; background: transparent; border: none;
      border-bottom: 1px solid var(--dim); color: #fff; font-size: 1.35rem; width: 3.4rem;
      text-align: center; outline: none; padding: 0.15rem 0; transition: border-color 0.2s;
    }
    .s-input:focus { border-bottom-color: #fff; }
    .s-input::-webkit-outer-spin-button,
    .s-input::-webkit-inner-spin-button { -webkit-appearance: none; }
    .s-input[type=number] { -moz-appearance: textfield; }

    .tog-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.45rem 0; font-size: 0.62rem; letter-spacing: 0.22em;
      color: var(--mid); border-bottom: 1px solid var(--dimmer);
    }
    .tog-row:last-child { border-bottom: none; }

    .sw {
      width: 30px; height: 16px; border: 1px solid var(--dim);
      position: relative; cursor: pointer; flex-shrink: 0;
      background: transparent; transition: border-color 0.2s;
    }
    .sw::after {
      content: ''; position: absolute; top: 3px; left: 3px; width: 8px; height: 8px;
      background: var(--dim); transition: transform 0.2s, background 0.2s;
    }
    .sw.on          { border-color: #fff; }
    .sw.on::after   { transform: translateX(14px); background: #fff; }

    #apply-btn {
      font-family: 'Share Tech Mono', monospace; font-size: 0.68rem; letter-spacing: 0.22em;
      background: #fff; color: #000; border: none; padding: 0.48rem 1.3rem;
      cursor: pointer; transition: opacity 0.15s;
    }
    #apply-btn:hover { opacity: 0.8; }

    /* â”€â”€ Focus tracker â”€â”€ */
    #focus-tracker {
      font-size: 0.58rem; letter-spacing: 0.25em;
      color: #555; /* readable but subtle at zero */
      text-align: center; transition: color 0.4s;
    }
    #focus-tracker.has-time { color: var(--mid); }

    /* â”€â”€ Shortcuts â”€â”€ */
    #shortcuts { font-size: 0.5rem; letter-spacing: 0.18em; color: #555; text-align: center; line-height: 2; }

    /* â”€â”€ Notification banner â”€â”€ */
    #notif-banner {
      font-size: 0.58rem; letter-spacing: 0.22em; color: #444;
      border: 1px solid var(--dimmer); padding: 0.38rem 0.9rem;
      cursor: pointer; transition: color 0.2s, border-color 0.2s; text-align: center;
    }
    #notif-banner:hover  { color: #888; border-color: #444; }
    #notif-banner.hidden { display: none; }
  </style>
</head>
<body>

<div class="flex flex-col items-center gap-5 w-full px-5" style="max-width:570px">

  <div id="notif-banner" onclick="requestNotifPermission()">[ ENABLE DESKTOP NOTIFICATIONS ]</div>

  <div id="mode-badge">â— WORK SESSION</div>

  <div id="timer-display" class="font-mono">
    <span id="mm">25</span><span id="colon">:</span><span id="ss">00</span>
  </div>

  <div id="status-line"></div>

  <div id="prog-track"><div id="prog-fill"></div></div>

  <div id="dots" class="flex gap-3"></div>

  <button id="skip-btn" style="display:none" onclick="skipPhase()">[ SKIP â†’ ]</button>

  <div class="flex gap-4">
    <button class="ctrl-btn" id="start-btn" onclick="startTimer()">START</button>
    <button class="ctrl-btn" id="pause-btn" onclick="pauseTimer()" disabled>PAUSE</button>
    <button class="ctrl-btn" id="reset-btn" onclick="confirmReset()">RESET</button>
  </div>

  <div class="flex gap-3">
    <button class="tog-btn on" id="sound-btn" onclick="toggleSound()">â™ª BEEP</button>
  </div>

  <div id="focus-tracker">FOCUSED TODAY Â· 0H 00M</div>

  <button id="edit-btn" onclick="toggleSettings()">[ EDIT SETTINGS ]</button>

  <div id="settings-panel" class="hidden">
    <div class="flex gap-5 justify-center items-end mb-5 flex-wrap">
      <div class="flex flex-col items-center gap-2">
        <span class="s-label">Work (min)</span>
        <input class="s-input" id="inp-work"      type="number" min="1" max="120" value="25" />
      </div>
      <div class="flex flex-col items-center gap-2">
        <span class="s-label">Break (min)</span>
        <input class="s-input" id="inp-break"     type="number" min="1" max="60"  value="5"  />
      </div>
      <div class="flex flex-col items-center gap-2">
        <span class="s-label">Long Break (min)</span>
        <input class="s-input" id="inp-longbreak" type="number" min="1" max="60"  value="15" />
      </div>
      <div class="flex flex-col items-center gap-2">
        <span class="s-label">Sessions</span>
        <input class="s-input" id="inp-sessions"  type="number" min="1" max="8"   value="4"  />
      </div>
    </div>
    <div style="border-top:1px solid #222; padding-top:0.9rem" class="mb-5">
      <div class="tog-row">
        <span>AUTO-START PHASES</span>
        <div class="sw on" id="sw-autostart" onclick="toggleAutoStart()"></div>
      </div>
    </div>
    <div class="flex justify-center">
      <button id="apply-btn" onclick="applySettings()">APPLY</button>
    </div>
  </div>

  <div id="shortcuts">SPACE Â· START / PAUSE &nbsp;|&nbsp; S Â· SKIP &nbsp;|&nbsp; R Â· RESET</div>

</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONFIG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const cfg = {
  workMin: 25, breakMin: 5, longBreakMin: 15,
  sessions: 4, sound: true, autoStart: true,
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RUNTIME STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let phase            = 'work';
let secondsLeft      = 0;
let totalSeconds     = 0;
let isRunning        = false;
let isTransitioning  = false;
let tickInterval     = null;
let startTimestamp   = null;   // Date.now() anchor for drift-free calc
let startSecondsLeft = 0;
let sessionsDone     = 0;
let focusedSeconds   = 0;
let resetConfirm     = false;
let resetConfirmTid  = null;
let transTid         = null;
let settOpen         = false;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DOM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const mmEl      = document.getElementById('mm');
const ssEl      = document.getElementById('ss');
const colonEl   = document.getElementById('colon');
const dispEl    = document.getElementById('timer-display');
const badgeEl   = document.getElementById('mode-badge');
const statusEl  = document.getElementById('status-line');
const progEl    = document.getElementById('prog-fill');
const dotsEl    = document.getElementById('dots');
const startBtn  = document.getElementById('start-btn');
const pauseBtn  = document.getElementById('pause-btn');
const resetBtn  = document.getElementById('reset-btn');
const skipBtn   = document.getElementById('skip-btn');
const editBtn   = document.getElementById('edit-btn');
const soundBtn  = document.getElementById('sound-btn');
const settPanel = document.getElementById('settings-panel');
const swAuto    = document.getElementById('sw-autostart');
const focusEl   = document.getElementById('focus-tracker');

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AUDIO â€” single shared context + persistent
   compressor chain (no node accumulation)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let _ctx    = null;
let _comp   = null;
let _master = null;

function getAudio() {
  if (!_ctx) {
    _ctx    = new (window.AudioContext || window.webkitAudioContext)();
    _comp   = _ctx.createDynamicsCompressor();
    _comp.threshold.value = -6;
    _comp.knee.value      = 2;
    _comp.ratio.value     = 8;
    _comp.attack.value    = 0.001;
    _comp.release.value   = 0.1;
    _master = _ctx.createGain();
    _master.gain.value    = 0.92;
    _master.connect(_comp);
    _comp.connect(_ctx.destination);
  }
  if (_ctx.state === 'suspended') _ctx.resume();
  return _ctx;
}

function beep() {
  if (!cfg.sound) return;
  try {
    const ctx = getAudio();
    [0, 0.32, 0.64].forEach(offset => {
      const t = ctx.currentTime + offset;

      // Primary high tone â€” sharp digital alarm
      const osc1 = ctx.createOscillator();
      const g1   = ctx.createGain();
      osc1.type = 'square';
      osc1.frequency.setValueAtTime(1760, t);
      g1.gain.setValueAtTime(0,    t);
      g1.gain.linearRampToValueAtTime(0.85, t + 0.008);
      g1.gain.setValueAtTime(0.85, t + 0.18);
      g1.gain.linearRampToValueAtTime(0,    t + 0.26);
      osc1.connect(g1);
      g1.connect(_master);
      osc1.start(t);
      osc1.stop(t + 0.28);

      // Sub tone â€” body and punch
      const osc2 = ctx.createOscillator();
      const g2   = ctx.createGain();
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(880, t);
      g2.gain.setValueAtTime(0,    t);
      g2.gain.linearRampToValueAtTime(0.45, t + 0.008);
      g2.gain.setValueAtTime(0.45, t + 0.18);
      g2.gain.linearRampToValueAtTime(0,    t + 0.26);
      osc2.connect(g2);
      g2.connect(_master);
      osc2.start(t);
      osc2.stop(t + 0.28);
    });
  } catch(e) {}
}

function toggleSound() {
  cfg.sound = !cfg.sound;
  soundBtn.classList.toggle('on', cfg.sound);
  saveCfg();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   NOTIFICATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function checkNotifBanner() {
  if (!('Notification' in window) || Notification.permission !== 'default') {
    document.getElementById('notif-banner').classList.add('hidden');
  }
}

function requestNotifPermission() {
  if (!('Notification' in window)) return;
  Notification.requestPermission().then(() => checkNotifBanner());
}

function notify(title, body) {
  try {
    if (typeof Notification !== 'undefined' && Notification.permission === 'granted') {
      new Notification(title, { body });
    }
  } catch(e) {}
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FOCUS TIME TRACKER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function todayKey() {
  const d = new Date();
  return `focus_day_${d.getFullYear()}_${d.getMonth()}_${d.getDate()}`;
}

function addFocusedTime(secs) {
  focusedSeconds += secs;
  renderFocusTracker();
  // Persist immediately â€” survives refresh
  try { localStorage.setItem(todayKey(), String(focusedSeconds)); } catch(e) {}
}

function renderFocusTracker() {
  const h    = Math.floor(focusedSeconds / 3600);
  const m    = Math.floor((focusedSeconds % 3600) / 60);
  const mStr = String(m).padStart(2, '0');
  focusEl.textContent = `FOCUSED TODAY Â· ${h}H ${mStr}M`;
  focusEl.classList.toggle('has-time', focusedSeconds > 0);
}

function loadFocusTime() {
  try {
    const raw = localStorage.getItem(todayKey());
    if (raw !== null) {
      focusedSeconds = parseInt(raw) || 0;
      renderFocusTracker();
    }
  } catch(e) {}
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LOCAL STORAGE â€” config
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function saveCfg() {
  try { localStorage.setItem('focus_v5', JSON.stringify(cfg)); } catch(e) {}
}

function loadCfg() {
  try {
    const raw = localStorage.getItem('focus_v5');
    if (!raw) return;
    const saved = JSON.parse(raw);
    ['workMin','breakMin','longBreakMin','sessions','sound','autoStart'].forEach(k => {
      if (saved[k] !== undefined) cfg[k] = saved[k];
    });
    document.getElementById('inp-work').value      = cfg.workMin;
    document.getElementById('inp-break').value     = cfg.breakMin;
    document.getElementById('inp-longbreak').value = cfg.longBreakMin;
    document.getElementById('inp-sessions').value  = cfg.sessions;
    soundBtn.classList.toggle('on', cfg.sound);
    swAuto.classList.toggle('on', cfg.autoStart);
  } catch(e) {}
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const LABELS = { work: 'WORK', break: 'BREAK', longbreak: 'LONG BREAK' };

function render() {
  const m    = Math.floor(secondsLeft / 60);
  const s    = secondsLeft % 60;
  const mStr = String(m).padStart(2, '0');
  const sStr = String(s).padStart(2, '0');
  mmEl.textContent = mStr;
  ssEl.textContent = sStr;
  document.title   = `${mStr}:${sStr} Â· ${LABELS[phase]}`;

  const pct = totalSeconds > 0 ? ((totalSeconds - secondsLeft) / totalSeconds) * 100 : 0;
  progEl.style.width = pct + '%';

  if (isRunning && secondsLeft <= 10 && secondsLeft > 0) {
    dispEl.classList.add('warning');
    colonEl.className = 'blink-fast';
  } else if (isRunning) {
    dispEl.classList.remove('warning');
    colonEl.className = 'blink';
  }
}

function renderDots() {
  dotsEl.innerHTML = '';
  for (let i = 0; i < cfg.sessions; i++) {
    const d = document.createElement('div');
    d.className = i < sessionsDone ? 'dot done'
      : (i === sessionsDone && phase === 'work' && isRunning) ? 'dot active'
      : 'dot';
    dotsEl.appendChild(d);
  }
}

function resetProgressBar() {
  progEl.style.transition = 'none';
  progEl.style.width      = '0%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    progEl.style.transition = 'width 0.5s linear';
  }));
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BUTTON STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function setBtns(start, pause, skip) {
  startBtn.disabled     = !start;
  pauseBtn.disabled     = !pause;
  skipBtn.style.display = skip ? '' : 'none';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DRIFT-FREE TICK
   â€” setInterval fires even when tab is hidden
   â€” Date.now() anchor prevents cumulative drift
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function tick() {
  if (!isRunning) return;

  const elapsed = Math.floor((Date.now() - startTimestamp) / 1000);
  const newSecs = Math.max(0, startSecondsLeft - elapsed);

  if (newSecs !== secondsLeft) {
    secondsLeft = newSecs;
    render();
    renderDots();
  }

  if (secondsLeft <= 0) {
    stopTick();
    isRunning = false;
    dispEl.classList.remove('running', 'warning');
    colonEl.className = '';

    if (phase === 'work') addFocusedTime(totalSeconds); // credit full completed session

    dispEl.classList.add('flash');
    setTimeout(() => dispEl.classList.remove('flash'), 600);
    beep();
    setTimeout(handlePhaseEnd, 700);
  }
}

function stopTick() {
  if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
}

// Snap display when returning to tab after timer expired while hidden
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && isRunning) tick();
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CORE TIMER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function startTimer() {
  if (isRunning || isTransitioning) return;
  getAudio(); // init AudioContext on user gesture

  colonEl.className    = 'blink';
  statusEl.textContent = '';
  isRunning            = true;
  startTimestamp       = Date.now();
  startSecondsLeft     = secondsLeft;

  dispEl.classList.add('running');
  dispEl.classList.remove('warning', 'flash');
  setBtns(false, true, true);
  editBtn.disabled = true;
  renderDots();

  tickInterval = setInterval(tick, 250);
}

function pauseTimer() {
  if (!isRunning) return;
  isRunning = false;
  stopTick();
  dispEl.classList.remove('running', 'warning');
  colonEl.className    = 'dimmed';
  statusEl.textContent = 'â€” PAUSED â€”';
  setBtns(true, false, true);
}

function skipPhase() {
  if (!isRunning && !isTransitioning) return;
  const wasRunning = isRunning; // save BEFORE clearing â€” fix dead-code bug
  stopTick();
  cancelTransition();
  isRunning = false;
  dispEl.classList.remove('running', 'warning');
  colonEl.className    = '';
  statusEl.textContent = '';

  // Credit only the time actually elapsed during this work segment
  if (phase === 'work' && wasRunning) {
    const elapsed = totalSeconds - secondsLeft;
    if (elapsed > 0) addFocusedTime(elapsed);
  }

  beep();
  setTimeout(handlePhaseEnd, 300);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PHASE LOGIC
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function handlePhaseEnd() {
  if (phase === 'work') {
    sessionsDone++;
    renderDots();
    if (sessionsDone >= cfg.sessions) {
      phase        = 'longbreak';
      secondsLeft  = cfg.longBreakMin * 60;
      totalSeconds = cfg.longBreakMin * 60;
      badgeEl.textContent = 'â— LONG BREAK';
      badgeEl.style.color = '#888';
      notify('ğŸ‰ All sessions complete!', `Enjoy your ${cfg.longBreakMin} min long break.`);
    } else {
      phase        = 'break';
      secondsLeft  = cfg.breakMin * 60;
      totalSeconds = cfg.breakMin * 60;
      badgeEl.textContent = 'â—‹ BREAK';
      badgeEl.style.color = '#888';
      notify('âœ“ Work session done!', `Take a ${cfg.breakMin} min break.`);
    }
  } else if (phase === 'break') {
    phase        = 'work';
    secondsLeft  = cfg.workMin * 60;
    totalSeconds = cfg.workMin * 60;
    badgeEl.textContent = 'â— WORK SESSION';
    badgeEl.style.color = '#fff';
    notify('â± Break over.', 'Time to focus!');
  } else if (phase === 'longbreak') {
    sessionsDone = 0;
    phase        = 'work';
    secondsLeft  = cfg.workMin * 60;
    totalSeconds = cfg.workMin * 60;
    badgeEl.textContent = 'â— WORK SESSION';
    badgeEl.style.color = '#fff';
    notify('âœ“ Long break done.', 'Starting a fresh set!');
    renderDots();
  }

  resetProgressBar();
  render();

  if (cfg.autoStart) {
    runTransition(LABELS[phase], startTimer);
  } else {
    editBtn.disabled = false;
    setBtns(true, false, false);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TRANSITION COUNTDOWN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function runTransition(label, onDone) {
  isTransitioning = true;
  setBtns(false, false, true);
  editBtn.disabled = true;
  let n = 3;
  function countdown() {
    statusEl.textContent = `${label} IN ${n}...`;
    document.title       = `${label} IN ${n}...`;
    if (n === 0) {
      statusEl.textContent = '';
      isTransitioning = false;
      onDone();
    } else {
      n--;
      transTid = setTimeout(countdown, 1000);
    }
  }
  countdown();
}

function cancelTransition() {
  clearTimeout(transTid);
  isTransitioning      = false;
  statusEl.textContent = '';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESET â€” double-confirm when active
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function confirmReset() {
  const isIdle = !isRunning && !isTransitioning
               && secondsLeft === totalSeconds && sessionsDone === 0;
  if (isIdle) { doReset(); return; }

  if (!resetConfirm) {
    resetConfirm = true;
    resetBtn.textContent = 'SURE?';
    resetBtn.classList.add('confirming');
    resetConfirmTid = setTimeout(() => {
      resetConfirm = false;
      resetBtn.textContent = 'RESET';
      resetBtn.classList.remove('confirming');
    }, 3000);
  } else {
    clearTimeout(resetConfirmTid);
    doReset();
  }
}

function doReset() {
  stopTick();
  cancelTransition();
  // Always clean confirm state â€” prevents button getting stuck as "SURE?"
  clearTimeout(resetConfirmTid);
  resetConfirm = false;
  resetBtn.textContent = 'RESET';
  resetBtn.classList.remove('confirming');

  isRunning    = false;
  phase        = 'work';
  sessionsDone = 0;
  secondsLeft  = cfg.workMin * 60;
  totalSeconds = cfg.workMin * 60;

  dispEl.classList.remove('running', 'warning', 'flash');
  colonEl.className    = '';
  statusEl.textContent = '';
  badgeEl.textContent  = 'â— WORK SESSION';
  badgeEl.style.color  = '#fff';

  resetProgressBar();
  setBtns(true, false, false);
  editBtn.disabled = false;
  renderDots();
  render();
  document.title = 'FOCUS';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SETTINGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function toggleSettings() {
  if (isRunning || isTransitioning) return;
  settOpen = !settOpen;
  settPanel.classList.toggle('hidden', !settOpen);
}

function applySettings() {
  const clamp = (id, lo, hi) =>
    Math.min(Math.max(parseInt(document.getElementById(id).value) || lo, lo), hi);
  cfg.workMin      = clamp('inp-work',      1, 120);
  cfg.breakMin     = clamp('inp-break',     1,  60);
  cfg.longBreakMin = clamp('inp-longbreak', 1,  60);
  cfg.sessions     = clamp('inp-sessions',  1,   8);
  document.getElementById('inp-work').value      = cfg.workMin;
  document.getElementById('inp-break').value     = cfg.breakMin;
  document.getElementById('inp-longbreak').value = cfg.longBreakMin;
  document.getElementById('inp-sessions').value  = cfg.sessions;
  saveCfg();
  doReset();
  settOpen = false;
  settPanel.classList.add('hidden');
}

// Live-clamp inputs while typing
['inp-work','inp-break','inp-longbreak','inp-sessions'].forEach(id => {
  document.getElementById(id).addEventListener('input', function() {
    const lo = parseInt(this.min), hi = parseInt(this.max), v = parseInt(this.value);
    if (!isNaN(v)) {
      if (v < lo) this.value = lo;
      if (v > hi) this.value = hi;
    }
  });
});

function toggleAutoStart() {
  cfg.autoStart = !cfg.autoStart;
  swAuto.classList.toggle('on', cfg.autoStart);
  saveCfg();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   KEYBOARD SHORTCUTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.code === 'Space') {
    e.preventDefault();
    if (isRunning) pauseTimer();
    else if (!isTransitioning) startTimer();
  }
  if (e.key.toLowerCase() === 's' && (isRunning || isTransitioning)) skipPhase();
  if (e.key.toLowerCase() === 'r') confirmReset();
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
loadCfg();
loadFocusTime();
secondsLeft  = cfg.workMin * 60;
totalSeconds = cfg.workMin * 60;
checkNotifBanner();
renderDots();
render();
renderFocusTracker();
</script>
</body>
</html>
